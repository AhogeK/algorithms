<!-- TOC -->
* [优先队列](#优先队列)
    * [优先队列与堆](#优先队列与堆)
      * [优先队列的实现](#优先队列的实现)
    * [树形结构](#树形结构)
      * [完全二叉树与满二叉树](#完全二叉树与满二叉树)
      * [使用数组表示完全二叉树](#使用数组表示完全二叉树)
    * [堆有序](#堆有序)
<!-- TOC -->
# 优先队列

> 优先队列是一种“谁优先级高谁先出来”的队列，一般用二叉堆等结构高效实现，适合做每次要动态找“最值”的问题。

优先队列（Priority Queue）是一种基础数据结构。与普通队列（Queue）不同，优先队列里的元素每一个都有“优先级”，
出队顺序不是先进先出，而是谁的优先级高谁先出队。

1. 基本概念
    * 优先队列是一种“每次取出的总是当前优先级最高的元素”的数据结构。
    * 常用于需要频繁找“最值”的场景，比如贪心算法、Dijkstra最短路、A\*寻路等。
2. 基本操作
    * 插入元素（Insert）：将一个带有优先级的元素加入队列
    * 删除（取出）优先级最高的元素（Pop/Extract）：每次都取出当前优先级最高的那个元素
    * 查看优先级最高的元素（Peek/Top）：不删除，只返回当前最高的元素
3. 实现方式
    * 用数组/链表实现时，最坏时间复杂度很高
    * 常用 **堆（Heap）** 实现，比如二叉堆（binary heap）
    * 堆实现下，插入和删除操作都是 $\mathcal{O}(\log n)$ 复杂度
    * STL/Java等标准库里的 `priority_queue` 就是基于堆实现的
4. 简单类比
    * 普通队列就像排队买票，谁先来谁先上车
    * 优先队列就像急诊挂号，每来一个病人都标记严重程度，医生优先处理更严重的
5. 常见用法举例
    * 最高分优先、最小距离优先等场景
    * 算法刷题中只要遇到“每次拿出当前最大/最小/最急/最重要的”，都能想到用优先队列

### 优先队列与堆

#### 优先队列的实现

优先队列的常见实现有三种方法，核心在于“如何同时兼顾效率和正确性（谁优先谁先出）”。下面按照从简单到高效的顺序讲解，并且会结合上面你说到的内容。

1. **无序数组实现**

    * 入队（添加元素）直接往数组末尾加；\
      时间复杂度： $\mathcal{O}(1)$
    * 出队（取出优先级最高）：每次都需要遍历一遍整个数组，找出优先级最高的那个元素再移除；\
      时间复杂度： $\mathcal{O}(n)$
    * 适用场景：入队特别频繁但出队很少的场景

2. **有序数组实现**

    * 保证数组始终有序（如降序排列），每次入队时找好位置后插入；\
      时间复杂度： $\mathcal{O}(n)$（通常需要移动元素）
    * 出队时，优先级最高元素一定在数组头/尾，一次操作即可；\
      时间复杂度： $\mathcal{O}(1)$
    * 适用场景：出队很频繁但入队不多的场景

3. **堆（heap）实现**

    * 堆是一种完全二叉树结构，可以高效地维护“当前优先级最高的元素”；
    * 入队和出队操作都可以在 $\mathcal{O}(\log n)$ 时间完成；
    * 二叉堆（binary heap）应用最广（如大顶堆/小顶堆，根据需求调整）；
    * 这样就做到了入队、出队都高效，效率远高于前两种方式！
    * 主流编程语言的 `priority_queue` 等库就是堆实现

4. **效率对比表（归纳）**

    | 实现方式 | 入队                    | 出队                    |
    |------|-----------------------|-----------------------|
    | 无序数组 | $\mathcal{O}(1)$      | $\mathcal{O}(n)$      |
    | 有序数组 | $\mathcal{O}(n)$      | $\mathcal{O}(1)$      |
    | 堆    | $\mathcal{O}(\log n)$ | $\mathcal{O}(\log n)$ |

### 树形结构

树形结构就是“每层分叉、层层递进”的数据结构，让数据的查找、插入、删除等操作更高效。
优先队列常用的“堆”就是一种特殊的二叉树，让找“优先级最高（或最低）”的操作极快。

#### 完全二叉树与满二叉树

简单来说，完全二叉树和满二叉树都是二叉树的特殊情况。

* **完全二叉树**
 
    * 概念：完全二叉树是一种特殊的二叉树，要求从上到下、从左到右，除了最后一层之外，都必须被填满，
      最后一层的结点集中在最左侧，不能有“中间空位”。
    * 形象比喻：就像阶梯似的，一层一层铺满，最后那一层即使没铺满，也一定是“一块一块从左往右铺的”，不能出现空缺。
    * 特点：适合用连续的数组存储，没有“左有右无”或“右有左无”的疏漏。
     
* **满二叉树**
 
    * 概念：满二叉树是更理想、更整齐的二叉树，每一层的结点数都达到最大值，即每个非叶子节点一定都有两个子节点，并且所有叶子节点全部在最后一层。
    * 形象比喻：像完美的三角形金字塔，最底下一行结点数是最多的，每一行都是“铺满”的。
    * 数学特性：深度为 $k$ 的满二叉树共有 $2^k - 1$ 个结点，每一层结点数是 $2^{层号-1}$。这是一个等比数列。
     
* **简明对比**
 
    |    | 完全二叉树              | 满二叉树                      |
    |----|--------------------|---------------------------|
    | 结构 | 除最后一层，无空位，最后一层左边紧凑 | 每层都满，没有空位，所有叶子都在同一层       |
    | 关系 | 满二叉树一定是完全二叉树       | 完全二叉树不一定是满二叉树             |
    | 举例 | 最后一层可能不满，但只要填的紧凑即可 | 每层都“满员”，一棵三层满二叉树有 $7$ 个节点 |

#### 使用数组表示完全二叉树

“使用数组表示完全二叉树”是因为完全二叉树结构非常规整，没有“空洞”和偏移，非常适合用连续的数组来存储。

1. **编号方式**

    * 按照“从上到下、从左到右”的顺序，依次编号每个节点。
    * 可以选择从下标 $0$ 或 $1$ 开始编号。

2. **下标的规律**

    * 假设节点编号（下标）为 $i$，数组存储为 `arr[i]`。
    * **从 $0$ 开始编号时：**
        * 父节点 $i$ 的左孩子下标是 $2i+1$，右孩子下标是 $2i+2$。
        * 子节点 $i$ 的父亲下标是 $\left\lfloor \frac{i-1}{2} \right\rfloor$。
    * **从 $1$ 开始编号时：**
        * 父节点 $i$ 的左孩子下标是 $2i$，右孩子下标是 $2i+1$。
        * 子节点 $i$ 的父亲下标是 $\left\lfloor \frac{i}{2} \right\rfloor$。

3. **优点**

    * 内存连续、定位高效。
    * 无需存储左右孩子的引用关系，用下标就能算出父子关系，减少空间和时间消耗。

4. **实际应用**

    * 特别适合二叉堆这类完全二叉树的结构，比如实现优先队列。
    * 使用数组后，可以用简单的下标关系完成“上浮”“下沉”等操作，提高各种操作的效率。

### 堆有序

“堆有序”就是堆（Heap）这种特殊完全二叉树一直满足的排序规则。它有两种基本形态：最大堆和最小堆。

1. **最大堆（大顶堆）**

    * **定义**：对于任意一个非根节点，其父节点的值 $\geq$自己的值。
    * **特点**：根节点（最顶端的那个）一定是全树中最大的值。
    * **形象理解**：每棵小树的“头”都比下面“身体”要大。
    * **举例**：

      ```
             9
            / \
           7   5
          / \
         6   3
      ```

        * 这里 $9 > 7,9 > 5,7 > 6,7 > 3$，都满足最大堆的堆有序性质。

2. **最小堆（小顶堆）**

    * **定义**：对于任意一个非根节点，其父节点的值 $\leq$自己的值。
    * **特点**：根节点一定是全树最小的值。
    * **举例**：

      ```
             1
            / \
           3   5
          / \
         7   6
      ```

        * 这里 $1 < 3,1 < 5,3 < 7,3 < 6$，都满足最小堆的堆有序性质。

3. **“堆有序”的本质**

    * 无论新增还是删除元素，始终保持父子之间“优先级递减/递增”的顺序。
    * 只保证“沿着从父到子”的顺序。**堆内所有节点之间并不是完全有序！**
    * 只需维护“父子之间”的有序关系，不需要像完全排序那样每个元素都比较过。

4. **直白归纳**

    * 堆有序 ≠ 全局有序
    * 最大堆/最小堆都只保证每一个父节点“比自己的所有子节点更有优先级（大或小）”
    * 所以堆顶永远是“最大（优先最大）”或“最小（优先最小）”的元素

5. **为什么重要?**

    * 这样结构一旦被打破，可以用“上浮/下沉”操作 $\mathcal{O}(\log n)$时间快速恢复。
    * 这正是堆能高效做优先队列、堆排序的核心原因。

---

[返回](../README.md)