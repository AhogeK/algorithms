<!-- TOC -->
* [数组里常见的两类算法](#数组里常见的两类算法)
  * [滑动窗口简介](#滑动窗口简介)
    * [算法核心原理](#算法核心原理)
      * [1. 基本定义](#1-基本定义)
      * [2. 时间复杂度优化](#2-时间复杂度优化)
    * [例题：「力扣」第 3 题：无重复字符的最长子串](#例题力扣第-3-题无重复字符的最长子串)
      * [核心思路：滑动窗口 + 哈希表](#核心思路滑动窗口--哈希表)
      * [代码详解](#代码详解)
      * [复杂度分析](#复杂度分析)
<!-- TOC -->

# 数组里常见的两类算法

数组中常见的两类算法它们是「滑动窗口」和「双指针」。其中，「滑动窗口」也可以理解为一种特殊的「双指针」

* 核心思想对比

    | **维度**    | **滑动窗口 (Sliding Window)**                    | **双指针 (Two Pointers)**              |
    |-----------|----------------------------------------------|-------------------------------------|
    | **定义**    | 维护一个**连续区间**（窗口），通过移动左右边界动态调整窗口大小，寻找满足条件的子区间 | 使用两个指针协同遍历数据结构，通过特定移动规则解决对称、匹配或搜索问题 |
    | **关注点**   | 窗口内部的整体属性（如和、频率、唯一性）                         | 两个指针所指元素的**关系**（如相等、对称、和值）          |
    | **连续性要求** | 必须处理**连续子序列**                                | 可以处理非连续元素（如链表去重、有序数组两数之和）           |

* 选择策略
 
    | 判断条件             | 推荐算法    |
    |------------------|---------|
    | 需要处理连续区间（子串/子数组） | 滑动窗口    |
    | 涉及多个元素的关联计算      | 双指针     |
    | 数据已排序或有排序可能性     | 双指针     |
    | 需要同时考虑前后关系       | 双指针（反向） |

* 总结

    | 维度        | 滑动窗口      | 双指针       |
    |-----------|-----------|-----------|
    | **数据连续性** | 必须连续      | 可离散       |
    | **移动方向**  | 同向        | 同向/反向/交错  |
    | **核心操作**  | 窗口扩展与收缩   | 指针协同移动    |
    | **典型优化**  | 哈希表记录字符位置 | 利用有序性跳过重复 |

## 滑动窗口简介

### 算法核心原理

#### 1. 基本定义

* **窗口**：连续子序列的抽象表示

* **窗口边界**：用左右指针（ $left$ , $right$ ）标记窗口范围

* **滑动规则**：

  * **固定窗口**：窗口大小不变，整体滑动
  * **可变窗口**：窗口大小动态变化，根据条件收缩/扩展

#### 2. 时间复杂度优化

* **暴力解法**： $O(n^2)$
* **滑动窗口**： $O(n)$ ，每个元素最多被左右指针各访问一次

### 例题：「力扣」第 3 题：[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[../src/array/LongestSubstringWithoutRepeatingCharacters.java](../src/array/LongestSubstringWithoutRepeatingCharacters.java)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希表存储字符及其最新索引
        Map<Character, Integer> charIndex = new HashMap<>();
        int maxLen = 0;  // 记录最大长度
        int left = 0;    // 窗口左边界

        for (int right = 0; right < s.length(); right++) {
            char currentChar = s.charAt(right);

            // 如果字符已存在且在当前窗口内，更新左边界
            if (charIndex.containsKey(currentChar) && charIndex.get(currentChar) >= left) {
                left = charIndex.get(currentChar) + 1;
            }

            // 更新字符的最新索引
            charIndex.put(currentChar, right);
            
            // 计算当前窗口长度并更新最大值
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
```

#### 核心思路：滑动窗口 + 哈希表

1. **滑动窗口**：维护一个窗口 `[left, right]`，窗口内的字符不重复。

2. **哈希表**：记录每个字符最后一次出现的索引。

3. **移动策略**：

   * **右指针**：每次向右扩展窗口，尝试包含新字符。
   * **左指针**：当新字符导致重复时，跳跃到重复字符的下一个位置。

#### 代码详解

1. **初始化**：
   * `charIndex`：哈希表记录字符的最后出现位置。
   * `maxLen`：记录最长子串长度。
   * `left`：窗口左边界初始为0。
2. **遍历字符串**：
   * 右指针 `right` 从0开始向右遍历每个字符。
   * 检查当前字符 `currentChar` 是否在哈希表中且其索引在窗口 `[left, right)` 内：
     * 若存在，将左边界移动到重复字符的下一个位置（`left = index + 1`）。
     * 若不存在或不在窗口内，保持左边界不变。
3. **更新哈希表**：
   * 无论是否移动左边界，都将当前字符的索引更新到哈希表中。
4. **计算窗口长度**：
   * 每次循环计算当前窗口长度 `right - left + 1`，更新最大值。

#### 复杂度分析

* **时间复杂度**： $O(n)$ ，每个字符被访问两次（左右指针各一次）。
* **空间复杂度**： $O(|\Sigma|)$ ， $\Sigma$ 为字符集大小（ASCII字符最多128个）。

