<!-- TOC -->
* [动态规划（上）](#动态规划上)
  * [动态规划概述](#动态规划概述)
    * [例题讲解：LCR 125.斐波那契数](#例题讲解lcr-125斐波那契数)
      * [算法思路](#算法思路)
      * [代码实现](#代码实现)
      * [复杂度分析](#复杂度分析)
    * [「记忆化递归」与「动态规划」](#记忆化递归与动态规划)
      * [它们到底是什么关系](#它们到底是什么关系)
      * [什么时候更适合用记忆化递归？](#什么时候更适合用记忆化递归)
      * [什么时候更适合用循环 DP？](#什么时候更适合用循环-dp)
    * [可以使用「动态规划」解决的问题需要具备三个性质](#可以使用动态规划解决的问题需要具备三个性质)
      * [重复子问题：同一个小问题会被反复遇到](#重复子问题同一个小问题会被反复遇到)
      * [最优子结构：整体最优能由子问题最优拼出来](#最优子结构整体最优能由子问题最优拼出来)
      * [无后效性：未来只依赖“状态”，不依赖“状态怎么来的”](#无后效性未来只依赖状态不依赖状态怎么来的)
      * [怎么快速判断“这题像不像 DP”](#怎么快速判断这题像不像-dp)
      * [常见“看起来像 DP 但会翻车”的点](#常见看起来像-dp-但会翻车的点)
    * [动态规划的核心双剑：状态与状态转移方程](#动态规划的核心双剑状态与状态转移方程)
      * [**什么是"状态"？**](#什么是状态)
      * [⚡ **什么是"状态转移方程"？**](#-什么是状态转移方程)
      * [🛠️ **如何推导状态转移方程？**](#-如何推导状态转移方程)
      * [🎨 **实现方式对比**](#-实现方式对比)
    * [动态规划三要素](#动态规划三要素)
      * [阶段（Stage）](#阶段stage)
      * [状态（State）](#状态state)
      * [决策（Decision）](#决策decision)
      * [把三要素连起来：状态转移](#把三要素连起来状态转移)
      * [例 1：爬楼梯（入门直觉）](#例-1爬楼梯入门直觉)
      * [例 2：0/1 背包（最常见模板）](#例-201-背包最常见模板)
      * [你可以用这张“建模清单”自检](#你可以用这张建模清单自检)
  * [理解「重复子问题」](#理解重复子问题)
    * [例题讲解：爬楼梯](#例题讲解爬楼梯)
      * [算法思路](#算法思路-1)
      * [代码实现](#代码实现-1)
      * [复杂度分析](#复杂度分析-1)
    * [完成「力扣」《剑指 Offer》第 46 题：把数字翻译成字符串(力扣 91.解码方法)](#完成力扣剑指-offer第-46-题把数字翻译成字符串--力扣-91解码方法-)
      * [算法思路](#算法思路-2)
      * [代码实现](#代码实现-2)
      * [复杂度分析](#复杂度分析-2)
  * [理解「最优子结构」](#理解最优子结构)
    * [「力扣」第 322 题：零钱兑换](#力扣第-322-题零钱兑换)
      * [算法思路](#算法思路-3)
      * [代码实现](#代码实现-3)
      * [复杂度分析](#复杂度分析-3)
    * [「力扣」第 279 题：完全平方数](#力扣第-279-题完全平方数)
      * [算法思路](#算法思路-4)
      * [代码实现](#代码实现-4)
      * [复杂度分析](#复杂度分析-4)
    * [「力扣」第 343 题：整数拆分](#力扣第-343-题整数拆分)
      * [算法思路](#算法思路-5)
      * [代码实现](#代码实现-5)
      * [复杂度分析](#复杂度分析-5)
    * [完成「力扣」第 377 题：组合总和 Ⅳ](#完成力扣第-377-题组合总和-ⅳ)
      * [算法思路](#算法思路-6)
      * [代码实现](#代码实现-6)
      * [复杂度分析](#复杂度分析-6)
  * [理解「无后效性」](#理解无后效性)
    * [「力扣」第 62 题：不同路径](#力扣第-62-题不同路径)
      * [算法思路](#算法思路-7)
      * [代码实现](#代码实现-7)
      * [复杂度分析](#复杂度分析-7)
    * [「力扣」第 198 题：打家劫舍](#力扣第-198-题打家劫舍)
      * [算法思路](#算法思路-8)
      * [代码实现](#代码实现-8)
      * [复杂度分析](#复杂度分析-8)
    * [完成「力扣」第 120 题：三角形最小路径和](#完成力扣第-120-题三角形最小路径和)
      * [算法思路](#算法思路-9)
      * [代码实现](#代码实现-9)
      * [复杂度分析](#复杂度分析-9)
<!-- TOC -->

# 动态规划（上）

> 动态规划（Dynamic Programming，简称 DP），听起来像是一种高深的“编程方式”，但它实际上是一种算法设计思想。

用一句话概括就是：**大事化小，小事化了，且绝不重复做同样的事。**

它核心的哲学是：**通过把原问题分解为相对简单的子问题的方式求解复杂问题**。但与“分治法”不同的是，这些子问题往往是**重叠**的，
动态规划会将每个子问题的解**存起来**（通常存在一个数组或哈希表中），当下次需要这个子问题的结果时，直接查表，而不是重新计算。

这是一种典型的**空间换时间**（Space for Time）的策略。

1. 通俗理解：1+1+1+1 的故事

   Quora 上有一个非常经典的解释：

   > **问：** 纸上写着 “ $1+1+1+1+1+1+1+1$”，问你结果是多少？\
   > **答：** 你数了一下，说是 $8$。
   >
   > **问：** 我在后面又加了一个 “ $+1$”，现在是多少？\
   > **答：** 你会立刻说是 $9$。
   >
   > **问：** 为什么你这次算出 $9$ 这么快？不需要重新数一遍前面的 $8$ 个 $1$ 吗？\
   > **答：** 因为我**记住了**前面的结果是 $8$，只需要 $8+1$ 就行了。

   这就是动态规划的核心：**记住所求过的解（Memoization/Tabulation），避免重复计算**。

2. 动态规划的两大核心性质

   如果一个问题能用动态规划解决，它通常具备以下两个特征：

   ① 重叠子问题 (Overlapping Subproblems)

   在求解过程中，同一个子问题会被多次调用。

    * **反例**：归并排序。虽然它分成了子数组，但左边的数组和右边的数组完全没关系，不重叠。这是“分治”。
    * **正例**：斐波那契数列。计算 $f(5)$ 需要 $f(4)$ 和 $f(3)$；计算 $f(6)$ 需要 $f(5)$ 和 $f(4)$。这里 $f(4)$ 就被重复利用了。

   ② 最优子结构 (Optimal Substructure)

   原问题的“最优解”包含其子问题的“最优解”。

    * **例子**：在这个图中求 $A \to C$ 的最短路径。如果最短路径经过 $B$，那么 $A \to B$ 的路径也必须是 $A$ 到 $B$ 之间的最短路径。
    * **意义**：我们可以通过组合子问题的最优解来构建原问题的最优解。

3. 解题四部曲

   做 DP 题时，通常按照这四个步骤思考：

    1. **定义状态（State Definition）：**\
       最重要的一步。你需要定义数组 `dp[i]` 或者 `dp[i][j]` 到底代表什么含义？

        * *例如：* `dp[i]` 表示爬到第 $i$ 阶楼梯的方法总数。

    2. **推导状态转移方程（State Transition Equation）：**\
       这是 DP 的灵魂。如何从已知的小规模状态推导出当前状态？

        * *例如：* 要到第 $i$ 阶，只能从第 $i-1$ 阶迈一步，或从 $i-2$ 阶迈两步。
        * 方程： $dp[i] = dp[i-1] + dp[i-2]$

    3. **初始化（Initialization/Base Case）：**\
       最基础的状态是多少？防止数组越界，也为递推提供起点。

        * *例如：* $dp = 0, dp = 1, dp = 2$。

    4. **确定遍历顺序（Traversal Order）：**\
       是从前向后算，还是从后向前算？

        * *例如：* 想算 $dp[i]$，必须先知道 $dp[i-1]$，所以要从 $i=3$ 开始从小到大遍历。

4. 举个例子：斐波那契数列

   计算第 $n$ 个斐波那契数。

   ❌ 暴力递归（Naive Recursion）

    ```
    int fib(int n) {
        if (n <= 1) return n;
        return fib(n - 1) + fib(n - 2);
    }
    ```

    * **问题**：计算 `fib(5)` 会计算 `fib(4)` 和 `fib(3)`，计算 `fib(4)` 又要算 `fib(3)`... `fib(3)` 被重复计算了多次。
    * **复杂度**：时间复杂度爆炸，约为 $\mathcal{O}(2^n)$。

   ✅ 动态规划（Dynamic Programming）

   我们开一个数组 `dp` 记录结果。

    ```
    int fib(int n) {
        if (n <= 1) return n;
        int[] dp = new int[n + 1];
        // 初始化
        dp[0] = 0;
        dp[1] = 1;
        // 状态转移
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
    ```

    * **优化**：每个状态只算一次。
    * **复杂度**：时间复杂度降为 $\mathcal{O}(n)$，空间复杂度 $\mathcal{O}(n)$（可进一步优化为 $\mathcal{O}(1)$）。

**当你发现一个问题可以分解，且分解后的子问题会重复出现时，请立刻想到：DP 大法好。**

## 动态规划概述

### 例题讲解：LCR 125.[斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof)

#### 算法思路

1. **朴素递归（不推荐 ❌）**

   如果直接翻译公式写递归，计算 $F(n)$ 需要计算 $F(n-1)$ 和 $F(n-2)$
   ，这会产生大量的重复计算。时间复杂度是指数级的 $\mathcal{O}(2^n)$，对于 $n=100$ 绝对会超时。

2. **记忆化搜索（自顶向下 ✅）**

   使用一个数组记录已经计算过的 $F(n)$，避免重复计算。这可以将复杂度降为 $\mathcal{O}(n)$，但需要额外的栈空间。

3. **迭代动态规划（自底向上 ✅）**

   我们可以从 $F(0)$ 和 $F(1)$ 开始，逐步计算 $F(2), F(3), \dots, F(n)$。\
   状态转移方程为：

   $$dp[i] = (dp[i-1] + dp[i-2]) \pmod{1000000007}$$

   这也是题目要求的核心思路。

4. **滚动数组优化（执行最快 🚀）**

   观察上述转移方程，计算 $dp[i]$ 只需要用到 $dp[i-1]$ 和 $dp[i-2]$ 这两个状态。这意味着我们不需要维护一个长度为 $n+1$
   的数组，只需要 **两个变量** 滚动更新即可。

    * 设 $a$ 代表 $F(i-2)$
    * 设 $b$ 代表 $F(i-1)$
    * 计算 $sum = (a + b) \\% MOD$，这里的 $sum$ 就是 $F(i)$
    * **滚动更新**：下一次循环时，原先的 $F(i-1)$ 变为 $F(i-2)$，原先的 $F(i)$ 变为 $F(i-1)$
      。即： $a \leftarrow b$， $b \leftarrow sum$。

   这种方法将空间复杂度降低到了极致的 $\mathcal{O}(1)$。

**🗝️ 核心知识点与技巧**

* **动态规划 (DP)**：将大问题分解为重叠子问题，通过状态转移求解。
* **空间优化 (滚动数组)**：当状态转移只依赖于前几个状态时，可以使用有限的变量代替数组，极大地节省内存。
* **取模运算性质**： $(a + b) \pmod m = ((a \pmod m) + (b \pmod m)) \pmod m$。在本题中，由于中间结果不会超过
  `Integer.MAX_VALUE`，直接相加后取模即可。

#### 代码实现

```java
public class Fib {
    public int fib(int n) {
        if (n < 2) return n;
        int a = 0;
        int b = 1;
        final int MOD = 1000000007;
        for (int i = 2; i <= n; i++) {
            int sum = (a + b) % MOD;
            a = b;
            b = sum;
        }
        return b;
    }
}
```

#### 复杂度分析

* **时间复杂度**： $\mathcal{O}(n)$
    * 代码包含一个从 $2$ 到 $n$ 的循环，循环内部的操作（加法、取模、赋值）都是常数时间 $\mathcal{O}(1)$。因此总时间与 $n$ 成正比。
* **空间复杂度**： $\mathcal{O}(1)$
    * 我们只使用了 `a`, `b`, `sum`, `i` 等几个有限的变量，没有使用随 $n$ 增长的数组或递归栈空间。

### 「记忆化递归」与「动态规划」

> “记忆化递归”和“动态规划（DP）”本质上在做同一件事：把一个问题拆成重叠子问题，并把子问题答案缓存起来，避免重复计算。
> 它们最大的区别通常不在“思想”，而在“写法”和“计算顺序”。

#### 它们到底是什么关系

记忆化递归可以理解成“自顶向下的 DP”（Top-down DP）：你按人类直觉写递归，把每个状态的答案存进 `memo`，下次再遇到同一状态就直接返回。

动态规划（常指循环写法）更像“自底向上的 DP”（Bottom-up DP）：你先确定状态的计算顺序，用 `dp` 数组从小到大（或按拓扑序）把所有需要的状态填出来，最后取目标状态。

很多教材会说：

* 记忆化递归 = DP 思想 + 递归 + 缓存
* 循环 DP = DP 思想 + 表格填充（tabulation）

**一个最小例子：斐波那契**

递推关系是：

$f(n)=f(n-1)+f(n-2)$

*记忆化递归（Top-down）*

* 你只会计算“真正用到的状态”
* 但有函数调用开销，并且要吃递归栈深度（比如 $n$ 很大时可能爆栈）

```java
Long[] memo = new Long[N];

long f(int n) {
    if (n <= 1) return n;
    if (memo[n] != null) return memo[n];

    return memo[n] = f(n - 1) + f(n - 2); // 赋值并返回
}
```

*循环 DP（Bottom-up）*

* 状态计算顺序清晰，通常更稳
* 一般不会爆栈，常数也更小

```java
long f(int n) {
    if (n <= 1) return n;
    long dp0 = 0, dp1 = 1;
    for (int i = 2; i <= n; i++) {
        long sum = dp0 + dp1;
        dp0 = dp1;
        dp1 = sum;
    }
    return dp1;
}
```

两者时间复杂度都能做到 $\mathcal{O}(n)$；区别更多体现在工程表现（栈、常数、可控性）上。

#### 什么时候更适合用记忆化递归？

下面这些场景，记忆化递归往往更顺手，甚至更不容易写错：

* 状态转移天然是“从目标往回问”的，比如区间 DP、树形 DP、博弈 DP（从根/目标状态递归下去很自然）
* 可达状态很稀疏：理论上状态空间很大，但实际只会访问其中一小部分（Top-down 只算访问到的）
* 你一时难以确定一个好用的“填表顺序”（Bottom-up 需要确保依赖已算完）

#### 什么时候更适合用循环 DP？

循环 DP 通常更适合追求稳定和性能的场合：

* 依赖关系很规则（例如线性、网格、背包），填表顺序简单明确
* 数据规模大，递归层数可能很深（避免爆栈）
* 需要进一步优化（滚动数组、位运算优化、严格控制内存布局等）

**一个实用的判断标准**

*如果你已经写出了“状态 + 转移”，但还没想清楚遍历顺序，那就先写记忆化递归把逻辑跑通；等你确认依赖关系和访问范围后，再考虑把它“翻译”成循环
DP 来提速和增强鲁棒性。*

### 可以使用「动态规划」解决的问题需要具备三个性质

> 动态规划（DP）能“好用”的核心原因，是它把一个大问题拆成很多小问题，并且让这些小问题的答案可以**复用**、可以拼回大问题、
> 还不会因为“之前怎么走”而产生额外麻烦。通常我们用三个性质来判断：重复子问题、最优子结构、无后效性。

#### 重复子问题：同一个小问题会被反复遇到

所谓重复子问题，说的是你用朴素递归/搜索去做时，会在不同分支里多次算到“同一种状态”。既然会重复，就值得把答案缓存起来（记忆化）或按顺序填表（递推）。

经典例子是斐波那契数列：递归会反复计算同样的 $f[k]$。

$f[n] = f[n-1] + f[n-2]$

判断小技巧：如果你画出递归调用树/搜索树，发现很多节点“长得一样”（同一组参数、同一状态定义），那就是重复子问题的强信号。

#### 最优子结构：整体最优能由子问题最优拼出来

最优子结构指：一个问题的最优解中，包含的子结构（子路径、子区间、子集合等）本身也必须是对应子问题的最优解；否则你可以替换成更优子解，让整体更优，出现矛盾。

比如很多“最短路/最小代价”类转移都长这样：到达 $i$ 的最优值来自某个前驱 $j$ 的最优值再加一段代价。

$dp[i] = \min\limits_{j < i}\Big(dp[j] + cost(j,i)\Big)$

注意：最优子结构不是“任何拆法都行”，而是“存在一种合理拆法使得最优可由子最优组合”。像 0/1 背包也满足：选或不选第 $i$
件物品，把问题拆成规模更小的背包子问题。

#### 无后效性：未来只依赖“状态”，不依赖“状态怎么来的”

无后效性（也常被类比成“马尔可夫性”）指：当你把问题抽象成某个状态 $dp[\cdot]$ 后，后续决策只需要这个状态值，不需要额外追溯历史细节；换句话说，状态信息必须“足够完备”。

比如你定义 $dp[i]$ 表示“考虑到第 $i$ 步的最优值”，那么从 $dp[i]$ 转移到 $dp[i+1]$ 的规则，不能依赖“达到 $i$
时具体选了哪些东西但状态里没记录”。一旦依赖了，就会出事：同样的 $dp[i]$ 数值可能对应多种历史，而这些历史对未来可行性/收益不同，导致转移不正确。

常见修复方式是把“缺失的历史信息”塞进状态里：

* 需要知道“已经用过哪些元素” → 状态加上集合/位掩码
* 需要知道“上一个字符/上一个位置” → 状态加上 last
* 需要知道“某些资源剩余量” → 状态加上容量/次数等维度

#### 怎么快速判断“这题像不像 DP”

可以用下面这些问法去“拷打题目”，基本就能定位：

* 是否能写出“状态 + 转移”，并且转移会反复用到相同状态（像递归树大量重叠）？这对应**重复子问题**
* 全局最优是否可以由若干更小规模的最优结果组合得到，而不会要求子问题用“非最优解”来成全整体？这对应**最优子结构**
* 我定义的状态，是否已经包含了未来决策所需的一切信息？如果还要问“你之前具体怎么选的”，那就是违反**无后效性**，需要扩状态

#### 常见“看起来像 DP 但会翻车”的点

* 把状态定义得太粗：例如只记“走到第 $i$ 位的最优值”，但实际上未来可选项取决于“之前选过哪些/最后一次出现位置”等隐藏信息
* 问题本身要求“路径必须简单（不重复点）”“序列必须全局不冲突”等全局约束：这通常会迫使你把“已访问集合/冲突信息”纳入状态，否则就会有后效性
* 最优子结构被额外规则破坏：例如某些“局部最优的子段”并不一定能出现在全局最优里（常见于带复杂耦合约束的组合优化）

### 动态规划的核心双剑：状态与状态转移方程

> 动态规划（Dynamic Programming, DP）是将一个复杂问题拆解为若干子问题，通过解决子问题并保存结果来避免重复计算的优化方法。在这个过程中，
> 最关键的就是**状态**和**状态转移方程**这两个概念。

#### **什么是"状态"？**

**状态**是对问题在某个特定阶段的描述，用变量来表示问题发展到不同阶段时的客观情况。简单理解：

> 状态就是把原问题和子问题中**会变化的量**找出来，用它们来标记问题的不同阶段

举几个例子理解 ✨：

* **斐波那契数列**：状态是"第 `n` 项"，用 `F(n)` 表示
* **爬楼梯问题**：状态是"爬到第 `i` 阶"，用 `dp[i]` 表示爬到第 `i` 阶的方法数
* **背包问题**：状态可能是"前 `i` 个物品、背包容量为 `j`"，用 `dp[i][j]` 表示

状态设计的好坏直接影响整个算法的复杂度和可行性。**找准状态变量**是动态规划的第一步，也是最需要思考的一步。

🔑 **状态的特性**

好的状态设计应该满足：

* **无后效性**（马尔可夫性）：当前状态一旦确定，就不受未来决策影响。换句话说，"只关注现在，不回头看"
* **阶段有序**：问题可以按时间或空间分成若干有序阶段，前一阶段为后一阶段提供信息

#### ⚡ **什么是"状态转移方程"？**

**状态转移方程**是描述不同状态之间关系的数学表达式，告诉我们如何从已知的子问题状态推导出当前问题的状态。

> 状态转移方程就是把"大问题的答案"和"小问题的答案"之间建立联系的桥梁 🌉

**经典例子**

**例1: 斐波那契数列**

* 状态：`F(n)` 表示第 `n` 个斐波那契数
* 状态转移方程： $F(n) = F(n-1) + F(n-2)$
* 边界条件： $F(0) = 0, \quad F(1) = 1$

**例2: 爬楼梯**

假设每次可以爬 1 阶或 2 阶，问爬到第 `n` 阶有多少种方法？

* 状态：`dp[i]` 表示爬到第 `i` 阶的方法总数
* 状态转移方程： $\text{dp}[i] = \text{dp}[i-1] + \text{dp}[i-2]$
* 含义：爬到第 `i` 阶，要么从第 `i-1` 阶爬 1 步，要么从第 `i-2` 阶爬 2 步

**例3: 最大子数组和（Maximum Subarray）**

给定数组 `nums`，找连续子数组的最大和。

* 状态：`dp[i]` 表示以 `nums[i]` 结尾的最大子数组和
* 状态转移方程： $\text{dp}[i] = \max(\text{dp}[i-1] + \text{nums}[i], \text{nums}[i])$
* 含义：当前位置的最大和，要么是"之前的最大和+当前元素"，要么是"从当前元素重新开始"

**例4: 最长递增子序列（LIS）**

找数组中最长递增子序列的长度。

* 状态：`dp[i]` 表示以第 `i` 个元素结尾的最长递增子序列长度
* 状态转移方程： $\text{dp}[i] = \max\limits_{0 \le j < i, \, \text{nums}[j] < \text{nums}[i]} (\text{dp}[j] + 1)$
* 含义：遍历 `i` 之前的所有元素 `j`，如果 `nums[j] < nums[i]`，就可以把 `nums[i]` 接到以 `nums[j]` 结尾的序列后面

#### 🛠️ **如何推导状态转移方程？**

推导状态转移方程的一般步骤：

1. **定义状态**：明确用什么变量表示子问题
2. **分析决策**：思考当前状态可以从哪些子状态转移而来
3. **建立关系**：用数学式子把当前状态和子状态联系起来
4. **确定边界**：设定初始条件（最小规模子问题的答案）

| 步骤       | 爬楼梯示例                       | 最大子数组和示例                                |
|----------|-----------------------------|-----------------------------------------|
| **定义状态** | `dp[i]` = 爬到第 `i` 阶的方法数     | `dp[i]` = 以 `nums[i]` 结尾的最大和            |
| **分析决策** | 可以从 `i-1` 或 `i-2` 到达        | 可以延续之前的和，或重新开始                          |
| **建立关系** | `dp[i] = dp[i-1] + dp[i-2]` | `dp[i] = max(dp[i-1]+nums[i], nums[i])` |
| **确定边界** | `dp[0] = 1, dp[1] = 1`      | `dp[0] = nums[0]`                       |

#### 🎨 **实现方式对比**

动态规划有两种实现方式：

| 方式       | 别名    | 特点                | 适用场景      |
|----------|-------|-------------------|-----------|
| **自顶向下** | 记忆化递归 | 从原问题出发递归，用备忘录避免重复 | 思路自然，调试方便 |
| **自底向上** | 递推/迭代 | 从最小子问题开始，逐步推导     | 效率更高，节省空间 |

**代码示例（以斐波那契为例）**

**自顶向下（记忆化递归）**：

```java
// Logic for Top-Down approach
Map<Integer, Integer> memo = new HashMap<>();

int fib(int n) {
    if (n <= 1) return n;
    if (memo.containsKey(n)) return memo.get(n);

    int result = fib(n - 1) + fib(n - 2);
    memo.put(n, result);
    return result;
}
```

**自底向上（递推）**：

```java
// Logic for Bottom-Up approach
int fib(int n) {
    if (n <= 1) return n;

    int[] dp = new int[n + 1];
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

### 动态规划三要素

> 动态规划（DP）本质是在“有很多重叠子问题、并且满足最优子结构”的问题里，把大问题拆成一堆小问题，**按顺序**算出来并缓存结果，避免重复计算。

#### 阶段（Stage）

阶段就是“你准备按什么顺序推进问题”。常见是按时间、按物品个数、按走到第几步、按区间长度等来推进。

* 例：0/1 背包里，“考虑到第 $i$ 个物品”为一个阶段
* 例：爬楼梯里，“走到第 $i$ 级台阶”为一个阶段

阶段的选择一般要求：从小阶段能推到大阶段，能形成从前往后的计算顺序（迭代）或递归顺序。

#### 状态（State）

状态就是“描述一个阶段下，你需要记住哪些信息，才能让后续决策有依据”。状态通常就是 DP 数组的下标含义。

常见状态设计思路：

* “我现在走到哪里了？”（位置/步数/区间端点）
* “我已经用了多少资源？”（容量/时间/次数）
* “我当前处于哪种模式？”（是否持有股票、是否用过一次特权等）

例如背包：`dp[i][w]` 可以表示“只看前 $i$ 个物品、容量为 $w$ 的最大价值”。

#### 决策（Decision）

决策就是“在某个状态下，你可以做哪些选择”。每个决策会把你带到另一个状态，并产生价值/代价，从而形成状态转移。

* 背包最典型决策：第 $i$ 个物品“选”或“不选”
* 爬楼梯决策：从第 $i$ 级往上走 1 步或 2 步
* 区间 DP 决策：选择哪个点作为最后一次分割/合并

#### 把三要素连起来：状态转移

有了“阶段推进顺序 + 状态定义 + 决策集合”，就能写出转移方程与边界条件。

#### 例 1：爬楼梯（入门直觉）

* 阶段：台阶编号 $i$
* 状态： $dp[i]$ 表示到第 $i$ 级的走法数
* 决策：最后一步来自 $i-1$（走 1 步）或 $i-2$（走 2 步）

转移：\
$dp[i]=dp[i-1]+dp[i-2]$

边界（示例）：`dp[0]=1, dp[1]=1`（具体取法看题意）

#### 例 2：0/1 背包（最常见模板）

* 阶段：物品编号 $i$
* 状态： $dp[i][w]$ 表示“前 $i$ 个物品、容量 $w$”的最大价值
* 决策：不选第 $i$ 个 / 选第 $i$ 个（前提是放得下）

转移（当 $w \ge w_i$）：\
$dp[i][w]=\max\limits\Big(dp[i-1][w],\ dp[i-1][w-w_i]+v_i\Big)$

当 $w < w_i$ 时只能不选： $dp[i][w]=dp[i-1][w]$。

#### 你可以用这张“建模清单”自检

* 阶段：我按什么顺序推进？（ $i$、长度、时间……）
* 状态：我需要记住哪些信息才够用？（下标含义要一句话说清）
* 决策：每个状态下有哪些选择？（选择会怎么改变状态）
* 边界：最小阶段/最小状态是多少？初值是什么？
* 答案：最终要的结果对应哪个状态？

## 理解「重复子问题」

### 例题讲解：[爬楼梯](https://leetcode.cn/problems/climbing-stairs)

#### 算法思路

**动态规划定义与转移**

设 `dp[i]` 表示“到达第 $i$ 阶的方法数”。

* 你能到达第 $i$ 阶，最后一步要么从 $i-1$ 走 $1$ 阶来，要么从 $i-2$ 走 $2$ 阶来\
  所以有转移：

$dp[i] = dp[i-1] + dp[i-2]$

初始条件很关键：

* `dp[1] = 1`（只有 `1`）
* `dp[2] = 2`（`1+1` 或 `2`）

由于题目 $1 \le n \le 45$，答案在 `int` 范围内，直接用 `int` 即可。

**执行用时最快的实现（滚动变量， $\mathcal{O}(1)$ 额外空间）**

虽然可以开数组 `dp[]`，但最快的常见写法是用两个变量滚动，减少内存访问与分配：

* `a` 代表 `dp[i-2]`
* `b` 代表 `dp[i-1]`
* 每次算出 `c = a + b` 作为 `dp[i]`，然后滚动 `a=b, b=c`

#### 代码实现

```java
public class ClimbingStairs {
    public int climbStairs(int n) {
        if (n <= 2) return 0;
        int a = 1;
        int b = 2;
        for (int i = 3; i <= n; i++) {
            int c = a + b;
            a = b;
            b = c;
        }
        return b;
    }
}
```

#### 复杂度分析

* 时间复杂度： $\mathcal{O}(n)$
* 空间复杂度： $\mathcal{O}(1)$

### 完成「力扣」《剑指 Offer》第 46 题：[把数字翻译成字符串(力扣 91.解码方法)](https://leetcode.cn/problems/decode-ways)

#### 算法思路

**动态规划定义**

令 `dp[i]` 表示：前 `i` 个字符（下标 `[0, i)` 这段前缀）有多少种解码方式。

那么最终答案是 `dp[n]`，其中 `n = s.length()`。

初始化（非常关键）：

* `dp[0] = 1`：空串只有 1 种“什么都不做”的方式（便于转移）
* `dp[1]`：如果 `s[0] != '0'`，则为 1；否则为 0

转移（对 `i >= 2`）：

* 单字符解码：若 `s[i-1] != '0'`，则 `dp[i] += dp[i-1]`
* 双字符解码：令 `x` 为两位数 `s[i-2..i-1]`，若 `10 <= x <= 26`，则 `dp[i] += dp[i-2]`

用公式写就是：

$dp[i] = \Big(\text{one}(i)\ ?\ dp[i-1] : 0\Big) + \Big(\text{two}(i)\ ?\ dp[i-2] : 0\Big)$

其中 `one(i)` 表示第 `i` 位能否单独解码，`two(i)` 表示最后两位能否一起解码。

**核心技巧与易错点**

* `'0'` 不能单独解码，所以遇到 `...0` 时，只有当它和前一位组成 `10` 或 `20` 才可能继续。
* 类似 `"06"` 这种前导零两位数不合法，因为两位数必须在 `10..26`。
* 当某个位置 `dp[i]` 变成 0，不代表整体立刻返回；但如果最终 `dp[n]=0` 就说明无解。

**代码实现（最快常见写法：滚动 DP， $\mathcal{O}(1)$ 额外空间）**

数组 `dp[]` 也能做，但滚动变量更省内存、访问更快。令：

* `prev2 = dp[i-2]`
* `prev1 = dp[i-1]`
* `cur = dp[i]`

#### 代码实现

```java
 public class DecodeWays {
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int n = s.length();
        char[] a = s.toCharArray();
        int prev2 = 1;
        int prev1 = 1;
        for (int i = 2; i <= n; i++) {
            int cur = 0;
            if (a[i - 1] != '0') cur += prev1;
            int two = (a[i - 2] - '0') * 10 + (a[i - 1] - '0');
            if (two >= 10 && two <= 26) cur += prev2;
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
}
```

#### 复杂度分析

* 时间复杂度： $\mathcal{O}(n)$，其中 `n <= 100`
* 空间复杂度： $\mathcal{O}(1)$（不算输入字符串）

## 理解「最优子结构」

### 「力扣」第 322 题：[零钱兑换](https://leetcode.cn/problems/coin-change)

#### 算法思路

**动态规划思路（自底向上）**

状态设计很直接：

* 状态： $dp[x]$ 表示凑出金额 $x$ 的最少硬币数
* 初始化： $dp = 0$，其余设为一个不可能的大值（记为 $INF$）
* 计算顺序：从小到大计算 $x=1\ldots amount$，保证用到的 $dp[x-c]$ 已经算好
* 答案：若 $dp[amount]$ 仍为 $INF$，返回 `-1`，否则返回它

为什么 $INF$ 可以取 `amount + 1`？因为当存在面额 $1$ 时，最多用 `amount` 枚硬币；即使不存在面额 $1$，`amount + 1`
也足够作为“不可达”的哨兵值，不会干扰最小值更新。

**核心知识点与技巧**

* 这是完全背包的“最小值”版本，但实现时不必纠结背包模板；用“按金额递推”的一维数组最简洁也最快。
* 用 `int[] dp` + 常量哨兵值，避免 `Integer.MAX_VALUE` 带来的溢出风险（比如做 `+1`）。
* 时间上限 $amount \le 10^4$，硬币数 $\le 12$，直接双重循环足够快。

#### 代码实现

```java
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        int inf = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, inf);
        dp[0] = 0;
        for (int x = 1; x <= amount; x++) {
            int best = inf;
            for (int c : coins) {
                if (c <= x) {
                    int prev = dp[x - c];
                    if (prev + 1 < best) best = prev + 1;
                }
            }
            dp[x] = best;
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

#### 复杂度分析

设硬币种类数为 $n$，目标金额为 $A$。

$$\text{时间复杂度} = \mathcal{O}(nA),\quad \text{空间复杂度} = \mathcal{O}(A)$$

### 「力扣」第 279 题：[完全平方数](https://leetcode.cn/problems/perfect-squares)

#### 算法思路

把每个平方数 $s \in {1,4,9,\dots}$ 看成“物品”，可以无限次使用；目标是凑出和为 `n`，并让“物品数量”最小。

这本质上是：在所有满足 $\sum a_i^2 = n$ 的表示中，最小化项数。

**动态规划思路（最快的 DP 方案）**

定义状态：

* `dp[i]`：凑出和为 `i` 的最少完全平方数数量

初始条件：

* `dp[0] = 0`（凑出 0 不需要任何数）
* 其他 `dp[i]` 先设为一个很大的值表示“尚未更新”

状态转移（枚举最后一个使用的平方数）：

* 对每个 `i`，枚举所有平方数 `sq`（且 `sq <= i`）\
  `dp[i] = min(dp[i], dp[i - sq] + 1)`

直觉是：如果最后选了一个平方数 `sq`，那前面必须用最优方式凑出 `i - sq`，再加上当前这个 `sq`，总数 `+1`。

由于 `n` 不大，直接做双循环即可，时间复杂度稳定，且在 LeetCode 上也是该题 DP 解里非常快的实现方式之一。

**核心知识点与技巧**

* 这是“最小值型 DP”，初始化要用“大数”，转移用 `min`。
* 预先把所有平方数 `1^2, 2^2, ..., floor(sqrt(n))^2` 存进数组，避免在内层反复计算平方与判断。
* 本题是“完全背包”的一种表述，但实现上用“按目标值 i 递增 + 枚举平方数”更直观。

#### 代码实现

```java
public class PerfectSquares {
    public int numSquares(int n) {
        int m = (int) Math.sqrt(n);
        int[] squares = new int[m];
        for (int i = 1; i <= m; i++) squares[i - 1] = i * i;
        int large = 10001;
        int[] dp = new int[n + 1];
        Arrays.fill(dp, large);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int sq : squares) {
                if (sq > i) break;
                int cand = dp[i - sq] + 1;
                if (cand < dp[i]) dp[i] = cand;
            }
        }
        return dp[n];
    }
}
```

#### 复杂度分析

设 $k = \lfloor \sqrt{n} \rfloor$。

* 时间复杂度： $\mathcal{O}(n \cdot k) = \mathcal{O}(n\sqrt{n})$
* 空间复杂度： $\mathcal{O}(n)$

在 `n <= 10^4` 时，上界大约是 $10^4 \times 100 = 10^6$ 量级循环，运行非常稳。

### 「力扣」第 343 题：[整数拆分](https://leetcode.cn/problems/integer-break)

#### 算法思路

把 `n` 拆成 `a + b` 后，最终最优解只可能来自两类情况：

* 不再继续拆 `b`：乘积是 `a * b`
* 继续把 `b` 拆到最优：乘积是 `a * dp[b]`

因此，对每个 `n`，我们只要枚举第一刀切在哪里即可（也就是枚举 `a`）。

**动态规划思路（执行用时很快的 DP）**

定义状态：

* `dp[i]`：把整数 `i` 拆分成至少两份后，能得到的最大乘积

初始值：

* `dp[2] = 1`（因为 `2 = 1 + 1`，乘积为 `1`）
* 其它 `dp[i]` 通过转移算出来

状态转移（枚举第一段长度 `j`）：

对每个 `i`，枚举 `j` 从 `1` 到 `i - 1`：

* 不拆后半段：`j * (i - j)`
* 拆后半段：`j * dp[i - j]`

取两者较大，再对所有 `j` 取最大值即可。

这种写法的优势是：`dp[x]` 始终代表“必须拆分”的最优值，逻辑非常干净，不需要额外状态区分“可拆可不拆”。

**核心知识点与技巧**

每次切分只需要关心“右边要不要继续拆”，这就是 `max(j * (i - j), j * dp[i - j])` 的来源。

另外一个小技巧是：其实枚举 `j` 只需要到 `i / 2`，因为 `j` 与 `i-j` 对称；但 `n` 最大才 `58`，全枚举也极快，代码更直观。

#### 代码实现

```java
public class IntegerBreak {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            int best = 0;
            for (int j = 1; j < i; j++) {
                int noSplit = j * (i - j);
                int splitRight = j * dp[i - j];
                best = Math.max(best, Math.max(noSplit, splitRight));
            }
            dp[i] = best;
        }
        return dp[n];
    }
}
```

#### 复杂度分析

内外两层循环：

* 时间复杂度： $\mathcal{O}(n^2)$
* 空间复杂度： $\mathcal{O}(n)$

这里 `n <= 58`，实际运行几乎是“瞬间”。

### 完成「力扣」第 377 题：[组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv)

#### 算法思路

给定互不相同的正整数数组 `nums`，你可以无限次使用其中任意元素，问有多少种不同的选取序列，使得序列元素之和等于 `target`
。由于“顺序不同视为不同组合”，这题本质是数“排列型方案数”，而不是传统“无序组合数”。

这个差异会直接影响动态规划的遍历方式：你要按“目标和”递推，才能把不同顺序自然区分开来。

**动态规划思路**

定义 `dp[s]`：表示“凑出总和为 `s` 的有序序列个数”。

* 初始：`dp[0] = 1`，表示凑出 0 的方法只有 1 种——空序列
* 递推：考虑最后一步选了哪个数 `x`\
  若最后一个数是 `x`，那么之前必须先凑出 `s - x`，其方案数是 `dp[s - x]`；把所有可行的 `x` 累加即可得到 `dp[s]`

用公式表示就是：

$$dp[s] = \sum_{x \in nums,\, x \le s} dp[s-x]$$

**核心知识点与技巧**

“顺序不同算不同”靠的不是额外去排列，而是靠**遍历顺序**把它数出来：外层枚举 `s` 从小到大，内层枚举 `nums` 作为“最后一步”。

直觉上看，`dp[s]` 统计的是“所有以某个数结尾的序列”之和，而不同的结尾选择、不同的构造路径，会对应到不同顺序的序列，自然就不会被合并掉。

#### 代码实现

```java
public class CombinationSumIV {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int s = 1; s <= target; s++) {
            int ways = 0;
            for (int x : nums)
                if (x <= s) ways += dp[s - x];
            dp[s] = ways;
        }
        return dp[target];
    }
}
```

#### 复杂度分析

设 `n = nums.length`。

* 时间复杂度： $\mathcal{O}(target \cdot n)$
* 空间复杂度： $\mathcal{O}(target)$

## 理解「无后效性」

### 「力扣」第 62 题：[不同路径](https://leetcode.cn/problems/unique-paths)

#### 算法思路

题目本质是在一个 $m \times n$
的网格里，从左上到右下，每一步只能“向右”或“向下”，问不同走法数量。因为到达某个格子的走法只取决于它的“上方格子”和“左方格子”，所以非常适合用
“动态规划（无后效性）”来做：当前状态完全由更小子问题决定，不需要关心路径怎么走来的细节。

把网格坐标看成从左上角 $(0,0)$ 走到 $(m-1,n-1)$。

到达任意格子 $(i,j)$ 的最后一步只有两种可能：

* 从上方 $(i-1,j)$ 向下走一步
* 从左方 $(i,j-1)$ 向右走一步

因此路径数满足经典递推：

$$dp[i][j] = dp[i-1][j] + dp[i][j-1]$$

边界也很直观：第一行只能一直向右，第一列只能一直向下，所以第一行/第一列全部是 $1$。

**最快的 DP：一维滚动数组**

直接开二维 $dp$ 可以做，但更快、更省内存的写法是**一维 DP 滚动**：

* 用 $dp[j]$ 表示“当前正在处理的这一行里，到达列 $j$ 的路径数”
* 当我们从左到右扫描一行时：
    * 更新前的 $dp[j]$ 其实是“上一行到达 $(i-1,j)$ 的路径数”
    * $dp[j-1]$ 是“当前行到达 $(i,j-1)$ 的路径数”（因为已经更新过了）
* 所以转移变为：

$$dp[j] \leftarrow dp[j] + dp[j-1]$$

初始化时把整行设为 $1$，表示第一行全是 $1$；之后每走到新的一行，就按上式从 $j=1$ 开始更新即可。

**核心知识点与技巧**

* **无后效性**： $dp[j]$ 的新值只依赖“旧的 $dp[j]$（上方）”与“当前行左侧的 $dp[j-1]$（左方）”，不依赖更久远的历史路径细节。
* **滚动数组**：用一维数组复用空间，把空间从 $m \cdot n$ 降到 $n$。
* **遍历方向**：必须从左到右更新，确保 $dp[j-1]$ 已经是当前行的新值。

#### 代码实现

* 由于题目保证答案 $\le 2 \times 10^9$，用 `int` 足够。
* `dp` 长度取 `n`（列数），先全部置为 `1`。
* 外层循环跑每一行（从第 2 行开始），内层从第 2 列开始累加。

```java
public class UniquePaths {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
```

#### 复杂度分析

* 时间复杂度：$\mathcal{O}(mn)$
* 空间复杂度：$\mathcal{O}(n)$

### 「力扣」第 198 题：[打家劫舍](https://leetcode.cn/problems/house-robber)

#### 算法思路

这题的关键约束是“相邻不能同时偷”，所以每一间房只有两种决策：偷或不偷；而“偷不偷第 $i$ 间”只会影响到第 $i+1$ 间，
天然满足动态规划的**无后效性**（当前最优只依赖更小规模的最优结果，不需要记住具体偷了哪些房子）。

**状态为什么成立**

设 $dp[i]$ 表示“从下标 $0 \sim i$ 的房子里，在不触发报警的前提下能偷到的最高金额”。

当你站在第 $i$ 间房前，最优策略只有两类：

* 不偷第 $i$ 间：收益就是 $dp[i-1]$
* 偷第 $i$ 间：因为不能偷相邻的 $i-1$，收益是 $dp[i-2] + nums[i]$

因此转移方程是：

$$dp[i] = \max(dp[i-1],\ dp[i-2] + nums[i])$$

**最快实现：滚动变量，空间 $\mathcal{O}(1)$**

二维/一维数组都能做，但这里状态只依赖 $i-1$ 与 $i-2$，所以用两个变量滚动即可：

* `prev2` 代表 $dp[i-2]$
* `prev1` 代表 $dp[i-1]$
* 迭代到第 $i$ 间时计算 `cur = max(prev1, prev2 + nums[i])`，再滚动更新

这种写法通常也是 LeetCode 里执行用时分布最靠前的一类：循环简单、无额外数组访问压力、分支少。

**核心知识点与技巧**

无后效性体现在： $dp[i]$ 只关心“到 $i-1$ 为止的最优金额”和“到 $i-2$ 为止的最优金额”，并不需要知道之前到底偷了哪些房子；历史信息已经被 $dp$ 值完全概括了。

另一个常用技巧是把“选或不选”类问题统一成“当前最优 = 不选当前 vs 选当前”的二选一结构，写出转移后再决定是否能做空间压缩。

#### 代码实现

下面代码按上述滚动思路实现，注意对长度为 $1$ 的数组单独返回即可。

```java
public class HouseRobber {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        int prev2 = nums[0];
        int prev1 = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            int cur = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
}
```

#### 复杂度分析

遍历一次数组即可，时间复杂度为 $\mathcal{O}(n)$，只用常数个变量，空间复杂度为 $\mathcal{O}(1)$。

### 完成「力扣」第 120 题：[三角形最小路径和](https://leetcode.cn/problems/triangle)

#### 算法思路

把每个位置看成一个结点，设当前在第 $i$ 行第 $j$ 列（从 $0$ 开始），下一步只能到第 $i+1$ 行的 $j$ 或 $j+1$。

关键在于：走到某个位置的最小代价，等于“当前位置的值”加上“下面两个可达位置里更小的最小代价”。

**动态规划思路**

定义状态：令 $dp[j]$ 表示“从当前正在处理的这一行的第 $j$ 个位置出发，到达底部的最小路径和”。

自底向上更省空间：

* 初始化：从最后一行开始，最后一行到达底部的最小和就是它自己，所以 $dp[j] = triangle[last][j]$
* 转移：当处理到第 $i$ 行时（从倒数第二行一路往上），对每个 $j$：

$dp[j] = triangle[i][j] + \min(dp[j],\ dp[j+1])$

这里的 $dp[j]$、 $dp[j+1]$ 在更新前代表“下一行的两个相邻位置到底部的最小和”，更新后变成“当前行该位置到底部的最小和”。因为当前行只依赖下一行，所以不会产生后效性问题。

最终答案就是处理到顶层后 $dp$。

**核心知识点与技巧**

* **无后效性**：状态转移只用到下一行（更接近底部）的最优结果，不需要知道路径怎么走到那里。
* 空间压缩：二维 DP 可压到一维，因为第 $i$ 行只依赖第 $i+1$ 行。
* 自底向上避免边界烦恼：不需要额外处理“走出三角形”的情况，永远只取 $dp[j]$ 与 $dp[j+1]$。

#### 代码实现

```java
public class Triangle {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        List<Integer> lastRow = triangle.get(n - 1);
        int[] dp = new int[lastRow.size()];
        for (int j = 0; j < lastRow.size(); j++) dp[j] = lastRow.get(j);
        for (int i = n - 2; i >= 0; i--) {
            List<Integer> row = triangle.get(i);
            for (int j = 0; j <= i; j++) dp[j] = row.get(j) + Math.min(dp[j], dp[j + 1]);
        }
        return dp[0];
    }
}
```

#### 复杂度分析

* 时间复杂度：访问三角形每个元素一次，为 $\mathcal{O}(n^2)$
* 空间复杂度：只用一个长度为最后一行的数组，为 $\mathcal{O}(n)$

***

[返回](../README.md)