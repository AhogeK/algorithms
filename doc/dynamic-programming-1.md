<!-- TOC -->
* [动态规划（上）](#动态规划上)
<!-- TOC -->

# 动态规划（上）

> 动态规划（Dynamic Programming，简称 DP），听起来像是一种高深的“编程方式”，但它实际上是一种算法设计思想。

用一句话概括就是：**大事化小，小事化了，且绝不重复做同样的事。**

它核心的哲学是：**通过把原问题分解为相对简单的子问题的方式求解复杂问题**。但与“分治法”不同的是，这些子问题往往是**重叠**的，
动态规划会将每个子问题的解**存起来**（通常存在一个数组或哈希表中），当下次需要这个子问题的结果时，直接查表，而不是重新计算。

这是一种典型的**空间换时间**（Space for Time）的策略。

1. 通俗理解：1+1+1+1 的故事

    Quora 上有一个非常经典的解释：

    > **问：** 纸上写着 “ $1+1+1+1+1+1+1+1$”，问你结果是多少？\
    > **答：** 你数了一下，说是 $8$。
    >
    > **问：** 我在后面又加了一个 “ $+1$”，现在是多少？\
    > **答：** 你会立刻说是 $9$。
    >
    > **问：** 为什么你这次算出 $9$ 这么快？不需要重新数一遍前面的 $8$ 个 $1$ 吗？\
    > **答：** 因为我**记住了**前面的结果是 $8$，只需要 $8+1$ 就行了。

    这就是动态规划的核心：**记住所求过的解（Memoization/Tabulation），避免重复计算**。

2. 动态规划的两大核心性质

    如果一个问题能用动态规划解决，它通常具备以下两个特征：

    ① 重叠子问题 (Overlapping Subproblems)

    在求解过程中，同一个子问题会被多次调用。

    * **反例**：归并排序。虽然它分成了子数组，但左边的数组和右边的数组完全没关系，不重叠。这是“分治”。
    * **正例**：斐波那契数列。计算 $f(5)$ 需要 $f(4)$ 和 $f(3)$；计算 $f(6)$ 需要 $f(5)$ 和 $f(4)$。这里 $f(4)$ 就被重复利用了。

    ② 最优子结构 (Optimal Substructure)

    原问题的“最优解”包含其子问题的“最优解”。

    * **例子**：在这个图中求 $A \to C$ 的最短路径。如果最短路径经过 $B$，那么 $A \to B$ 的路径也必须是 $A$ 到 $B$ 之间的最短路径。
    * **意义**：我们可以通过组合子问题的最优解来构建原问题的最优解。

3. 解题四部曲

    做 DP 题时，通常按照这四个步骤思考：

    1. **定义状态（State Definition）：**\
       最重要的一步。你需要定义数组 `dp[i]` 或者 `dp[i][j]` 到底代表什么含义？

        * *例如：* `dp[i]` 表示爬到第 $i$ 阶楼梯的方法总数。

    2. **推导状态转移方程（State Transition Equation）：**\
       这是 DP 的灵魂。如何从已知的小规模状态推导出当前状态？

        * *例如：* 要到第 $i$ 阶，只能从第 $i-1$ 阶迈一步，或从 $i-2$ 阶迈两步。
        * 方程： $dp[i] = dp[i-1] + dp[i-2]$

    3. **初始化（Initialization/Base Case）：**\
       最基础的状态是多少？防止数组越界，也为递推提供起点。

        * *例如：* $dp = 0, dp = 1, dp = 2$。

    4. **确定遍历顺序（Traversal Order）：**\
       是从前向后算，还是从后向前算？

        * *例如：* 想算 $dp[i]$，必须先知道 $dp[i-1]$，所以要从 $i=3$ 开始从小到大遍历。

4. 举个例子：斐波那契数列

    计算第 $n$ 个斐波那契数。

    ❌ 暴力递归（Naive Recursion）

    ```
    int fib(int n) {
        if (n <= 1) return n;
        return fib(n - 1) + fib(n - 2);
    }
    ```

    * **问题**：计算 `fib(5)` 会计算 `fib(4)` 和 `fib(3)`，计算 `fib(4)` 又要算 `fib(3)`... `fib(3)` 被重复计算了多次。
    * **复杂度**：时间复杂度爆炸，约为 $\mathcal{O}(2^n)$。

    ✅ 动态规划（Dynamic Programming）

    我们开一个数组 `dp` 记录结果。

    ```
    int fib(int n) {
        if (n <= 1) return n;
        int[] dp = new int[n + 1];
        // 初始化
        dp[0] = 0;
        dp[1] = 1;
        // 状态转移
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
    ```

    * **优化**：每个状态只算一次。
    * **复杂度**：时间复杂度降为 $\mathcal{O}(n)$，空间复杂度 $\mathcal{O}(n)$（可进一步优化为 $\mathcal{O}(1)$）。

**当你发现一个问题可以分解，且分解后的子问题会重复出现时，请立刻想到：DP 大法好。**

***

[返回](../README.md)