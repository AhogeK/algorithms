<!-- TOC -->
* [非比较排序算法](#非比较排序算法)
  * [计数排序](#计数排序)
    * [核心原理](#核心原理)
    * [适用条件](#适用条件)
    * [思路](#思路)
    * [代码](#代码)
      * [示例](#示例)
    * [复杂度（输入数组arr，长度n，最大值k）](#复杂度输入数组arr长度n最大值k)
      * [关键说明：](#关键说明)
<!-- TOC -->

# 非比较排序算法

## 计数排序

> 计数排序是一种非比较型的排序算法，它通过计算数组中每个元素出现的次数来进行排序。这种算法特别适用于对一定范围内的整数进行排序。

### 核心原理

* **统计频率**：统计每个数值出现的次数
* **累计定位**：计算每个数值的最终位置
* **反向填充**：逆向遍历原数组保持稳定性


### 适用条件

1. 要求待排序元素必须是 **非负整数** 或 **可映射到非负整数**（如字符 ASCII 码、有限范围的浮点数定点表示等）
2. 数据范围（值域）较小
3. 需要稳定排序
4. 有线性时间复杂度要求
5. 内存空间充足

### 思路

* **确定范围**

  找到待排序数组中的最大值 $k$ ，确定统计范围 $[0, k]$ 。

* **统计频率**

  创建长度为 $k+1$ 的计数数组 `count` ，遍历原数组统计每个元素出现的次数：\
  $\text{count}[i] = \text{元素} \ i \ \text{出现的次数}$ \
  例如数组 `[3,1,2,3]` 统计后得到 `count = [0,1,1,2]`。

* **计算前缀和**

  将 `count` 数组转换为累积计数（前缀和），此时：\
  $\text{count}[i] = \text{小于等于} \ i \ \text{的元素总个数}$ \
  例如 `count = [0,1,2,4]` 表示元素 3 的最后位置是索引 3。

* **反向填充**

  从原数组**末尾向前遍历**，根据 `count` 数组确定每个元素的最终位置，填充到结果数组后递减对应计数值。\
  **反向遍历保证稳定性**（相同元素的相对顺序不变）。

### 代码

[../src/sort/CountingSort.java](../src/sort/CountingSort.java)

```java
public class CountingSort implements ISortingAlgorithm {

    @Override
    public void sortArray(int[] nums) {
        if (nums.length == 0) return;

        // 找最大值
        int max = nums[0];
        for (int num : nums) {
            if (num > max) max = num;
        }

        // 初始化计数数组
        int[] count = new int[max + 1];
        for (int num : nums) {
            count[num]++;
        }

        // 累加计数（计算最终位置）
        for (int i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }

        // 反向填充结果数组
        int[] output = new int[nums.length];
        for (int i = nums.length - 1; i >= 0; i--) {
            int current = nums[i];
            // 最小就是只出现1次，放在下标0，所以-1
            output[count[current] - 1] = current;
            count[current]--;
        }

        // 拷贝回原数组，使用System.arraycopy是因为`System.arraycopy` 是
        // JVM 内置的本地方法（native method），底层通过内存块复制实现，
        // 时间复杂度 $O(1)$
        System.arraycopy(output, 0, nums, 0, nums.length);
    }
}
```

#### 示例

让我们一步一步分析对数组 `[4, 2, 2, 8, 3, 3, 1]` 进行计数排序的过程：

1. 统计频率

    ```text
    count[0] = 0   (0出现0次)
    count[1] = 1   (1出现1次)
    count[2] = 2   (2出现2次)
    count[3] = 2   (3出现2次)
    count[4] = 1   (4出现1次)
    count[5] = 0   (5出现0次)
    count[6] = 0   (6出现0次)
    count[7] = 0   (7出现0次)
    count[8] = 1   (8出现1次)
    ```

2. 累计次数

    * `count[1] = count[1] + count[0] = 1 + 0 = 1`
    * `count[2] = count[2] + count[1] = 2 + 1 = 3`
    * `count[3] = count[3] + count[2] = 2 + 3 = 5`
    * `count[4] = count[4] + count[3] = 1 + 5 = 6`
    * `count[5] = count[5] + count[4] = 0 + 6 = 6`
    * `count[6] = count[6] + count[5] = 0 + 6 = 6`
    * `count[7] = count[7] + count[6] = 0 + 6 = 6`
    * `count[8] = count[8] + count[7] = 1 + 6 = 7`
    * 累计次数表示的是：**有多少个元素的值小于或等于索引值**。
    * 例如：``count[3] = 5`` 意味着原数组中有5个元素的值 ≤ 3（包括1个值为1的元素，2个值为2的元素和2个值为3的元素）。

3. 构建排序后的数组

    1. 处理元素 `1`：

        * `count[1] = 1`，表示有1个元素 ≤ 1
        * 将 `1` 放在位置 `count[1]-1 = 0` 上
        * 更新 `count[1] = 0`

    2. 处理第二个元素 `3`：

        * `count[3] = 5`，表示有5个元素 ≤ 3
        * 将 `3` 放在位置 `count[3]-1 = 4` 上
        * 更新 `count[3] = 4`

    3. 处理第一个元素 `3`：

        * `count[3] = 4`，表示现在有4个元素 ≤ 3
        * 将 `3` 放在位置 `count[3]-1 = 3` 上
        * 更新 `count[3] = 3`

    4. 处理元素 `8`：

        * `count[8] = 7`，表示有7个元素 ≤ 8
        * 将 `8` 放在位置 `count[8]-1 = 6` 上
        * 更新 `count[8] = 6`

    5. 依此类推，最终得到排序数组：`[1, 2, 2, 3, 3, 4, 8]`

### 复杂度（输入数组arr，长度n，最大值k）

$$\text{时间复杂度：} O(n + k) \\\ \text{空间复杂度：} O(n + k)$$

#### 关键说明：

* ${n}$：待排序元素个数
* ${k}$：元素的取值范围（最大值与最小值之差 + 1）

1. **时间复杂度分析** 

    * **统计阶段**：遍历 ${n}$ 个元素，耗时 ${O(n)}$
    * **累加阶段**：遍历 ${k}$ 个计数单元，耗时 ${O(k)}$
    * **回填阶段**：再次遍历 ${n}$ 个元素，耗时 ${O(n)}$
    * 总时间 ${O(n + k)}$

2. **空间复杂度分析**

    * 需要 ${k}$ 大小的计数数组
    * 需要 ${n}$ 大小的输出数组
    * 总空间 ${O(n + k)}$

|      | 最坏时间复杂度       | 平均时间复杂度                            | 最好时间复杂度       | 额外空间复杂度     | 稳定性 | 是否原地排序 |
|------|---------------|------------------------------------|---------------|-------------|-----|--------|
| 选择排序 | $O(N^2)$      | $O(N^2)$                           | $O(N^2)$      | $O(1)$      | 不稳定 | 原地排序   |
| 冒泡排序 | $O(N^2)$      | $O(N^2)$                           | $O(N)$        | $O(1)$      | 稳定  | 原地排序   |
| 插入排序 | $O(N^2)$      | $O(N^2)$                           | $O(N)$        | $O(1)$      | 稳定  | 原地排序   |
| 希尔排序 | $O(N^2)$      | $O(n^{1.25}) \sim O(1.6 n^{1.25})$ | （没有相关研究）      | $O(1)$      | 不稳定 | 原地排序   |
| 归并排序 | $O(N \log N)$ | $O(N \log N)$                      | $O(N \log N)$ | $O(N)$      | 稳定  | 非原地排序  |
| 快速排序 | $O(N^2)$      | $O(N \log N)$                      | $O(N \log N)$ | $O(\log N)$ | 不稳定 | 原地排序   |
| 计数排序 | $O(N + K)$    | $O(N + K)$                         | $O(N + K)$    | $O(N + K)$  | 稳定  | 非原地排序  |

