<!-- TOC -->
* [并查集](#并查集)
  * [并查集简介](#并查集简介)
    * [并查集的基本思想](#并查集的基本思想)
    * [数据结构实现](#数据结构实现)
    * [基本代码](#基本代码)
    * [应用举例](#应用举例)
    * [并查集是树的集合](#并查集是树的集合)
    * [连通分量](#连通分量)
    * [理解「连通性」与「路径问题」](#理解连通性与路径问题)
    * [并查集的抽象数据类型](#并查集的抽象数据类型)
  * [并查集的 quick-find 实现](#并查集的-quick-find-实现)
    * [原理说明](#原理说明)
    * [例子](#例子)
    * [代码实现](#代码实现)
    * [复杂度分析](#复杂度分析)
    * [优缺点](#优缺点)
    * [例：「力扣」第 547 题：朋友圈（ps. 现题目为省份数量）](#例力扣第-547-题朋友圈ps-现题目为省份数量)
      * [算法思路](#算法思路)
      * [核心知识点与技巧](#核心知识点与技巧)
      * [代码实现](#代码实现-1)
      * [复杂度分析](#复杂度分析-1)
  * [并查集的 quick-union 实现](#并查集的-quick-union-实现)
    * [基本思想](#基本思想)
    * [操作详解](#操作详解)
    * [代码实现（未优化版本）](#代码实现未优化版本)
    * [复杂度分析](#复杂度分析-2)
    * [优缺点](#优缺点-1)
      * [优点](#优点)
      * [缺点](#缺点)
    * [完成「力扣」第 547 题：朋友圈(即省份数量，用quick-union实现)](#完成力扣第-547-题朋友圈即省份数量用quick-union实现)
      * [quick-union 思路](#quick-union-思路)
      * [整体步骤](#整体步骤)
      * [时间复杂度](#时间复杂度)
<!-- TOC -->

# 并查集

## 并查集简介

> 并查集（Union-Find Set，Disjoint Set Union，简称 DSU）是一种常用于解决“集合合并”与“查找连通性”问题的数据结构。
> 常见于处理“动态连通性”、“判断是否在同一集合”、“无向图判环”等场景，比如 Kruskal 最小生成树算法。

### 并查集的基本思想

主要支持两个操作：

1. **合并操作（Union）**：把两个集合合并为一个集合。
2. **查找操作（Find）**：判断某个元素属于哪个集合，通常找“代表元”或“根节点”。

### 数据结构实现

* 用数组 `parent[]` 记录每个元素的“父节点”。初始时，每个元素是自己的父节点，即独立集合。
* 查找时一路递归/迭代向上找，直到到达自己的根（即`parent[x] == x`）。
* 合并时，把一个元素的根节点挂到另一个根节点下。

**优化：路径压缩 + 按秩合并**

* 路径压缩：在`find`操作时，把沿途的点全部直接挂到根上，大大加速后续查找。
* 按秩/按大小合并：总是把个数少的/高度矮的集合并到多的/高的集合下，避免树变高。

这两个优化使得每次操作的均摊复杂度几乎是常数 $\mathcal{O}(1)$，实际上是 $\mathcal{O}(\alpha(n))$，
其中 $\alpha$是[反阿克曼函数](https://www.geeksforgeeks.org/inverse-ackermann-function/)。

### 基本代码

```java
// 初始化
int[] parent = new int[n];
for (int i = 0; i < n; i++) {
    parent[i] = i;
}

// 查找根节点 + 路径压缩
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

// 合并
void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        parent[rootX] = rootY;
    }
}
```

### 应用举例

* 判断两个元素是否属于同一个集合：比较`find(x)`和`find(y)`
* 求连通分量数量（如“朋友圈”问题）
* 动态连通性维护（如 Kruskal）

### 并查集是树的集合

* 每个集合对应“一棵树”。
* 树的每个节点代表一个元素，树的根节点代表这个集合的代表元（根）。
* 多个集合，实际上就是多棵互不相交的树的集合。

比如 $n$ 个初始元素，各自成集，每个都是单独的一棵树（单节点树）；随着合并过程，不断把树合并成更大的树，最终可能只剩下一棵大树（即所有元素全连通）。

**为什么用树？**

* 节点只需要记录“父节点是谁”，只需一个 `parent[]` 数组，空间和实现都很高效。
* 查找某元素属于哪个集合，只需往上查找其父亲直到根节点（树的根就是代表这个集合的标记）。
  * “查找”就是“向上找根结点”的过程。
* 合并两个集合，只需把一棵树的根挂到另一棵树的根下面。

### 连通分量

* 一个[无向图](https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/)中的“连通分量”指的是：极大地连通的子图。
* 在同一个连通分量里的任意两个顶点之间，都有路径能够互通。
* 不同连通分量之间，任意一对顶点都不连通。

1. **更通俗的理解**

    把无向图的所有节点想象成一群点，通过边连起来。如果一群点之间可以互相走到，那么它们属于同一个连通分量；走不到的，属于不同的连通分量。\
    比如下面这个无向图：

    ```
    A --- B --- C

    D --- E

    F
    ```

    这个图有：
    * $3$ 个连通分量：
      * ${A, B, C}$
      * ${D, E}$
      * ${F}$

2. **形式化定义**
 
   对于无向图 $G = (V, E)$：

   * 连通分量是极大的连通子图。极大是指：没有更多的顶点能加入当前子图而保持连通。

3. **和并查集的关系**

    * 用并查集维护连通分量时，每个连通分量就是并查集中一棵树。
    * 当我们对边 $(u, v)$ 执行合并操作时，就是把 $u$ 和 $v$ 两个连通分量合成一个。
    * 最终，树的数量（根结点的数量）就是连通分量数量。

    比如代码求无向图的连通分量个数：

    ```java
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (parent[i] == i) {
            count++; // 每个根就是一个连通分量
        }
    }
    ```

**总之连通分量就是一副图里“任意两点互通”的最大分组。用并查集，每个集合对应一个连通分量。**

### 理解「连通性」与「路径问题」

*这两个概念都与图论密不可分，是学习并查集以及常见算法题的基础。*

1. **连通性（Connectivity）**

    **定义：**

    * 连通性指的是图中任意两个点之间能否通过若干条边互相到达。
    * 在**无向图**里，只要有一条路径可以连接起 $u$ 和 $v$，则它们“连通”。
    * 如果图被分成了几块（连通分量），则不同分量之间任意两个点都无法互通。

    **例1：**

    * 下面的无向图中 $A, B, C, D$ 连通， $E, F$ 连通，但AB能不能走到E？不能——它们不连通。

      ```
      A---B---C
          |
          D     E---F
      ```

    **应用：**

    * 判断网络是否“整体连通”？
    * 两个人在朋友圈里是否能通过朋友关系互相认识？
    * 地图上岛屿块的数量

2. **路径问题（Path Problem）**

    **定义：**

    * 路径问题研究的是：从一个点 $u$ 到另一个点 $v$，是否存在一条边路径？如果有，路径最短是多少？一共有多少条？等等。
    * 路径可以有多种约束：最短路径、最大权路径、固定长度的路径等。

    **常见类型：**

    * 判断路径是否存在（可达问题）
    * 求最短/最长路径长度
    * 计算所有可能路径条数

    **例2：**

    * 在下图中，从 $A$ 到 $D$ 是否有路径？
      ```
      A---B---C
          |
          D
      ```
      可以走 $A \to B \to D$ 或 $A \to B \to C \to B \to D$（但第二条包含环，通常只关心最短路径）。

    **算法工具：**

    * 并查集解决“可达性/连通性”问题，即问“ $u$ 到 $v$ 有无路”。
    * BFS/DFS 或 Dijkstra 算法解决“路径长度/方案数/最短距离”等。

3. **两者区别和联系**

    * “连通性”问的是**能不能到**，简称“可达”（有路径即可，不关心具体路线）。
        * 只关心有无，典型用并查集、Flood Fill等方法。
    * “路径问题”关注**怎么到**、**多远**、有几种走法等。
        * 可能需要具体路线、最短距离、经过哪些节点等。

### 并查集的抽象数据类型

| 返回值       | 方法名                         | 方法描述                               |
|-----------|-----------------------------|------------------------------------|
| 构造函数无返回值  | `UnionFind(int N)`          | 初始化并查集                             |
| `void`    | `union(int x, int y)`       | 在 `x` 和 `y` 之间添加一条连接               |
| `int`     | `find(int x)`               | 返回 `x` 所在的连通分量的标识                  |
| `boolean` | `isConnected(int x, int y)` | 如果 `x` 和 `y` 存在于同一个连通分量中则返回 `true` |
| `int`     | `getCount()`                | 返回连通分量的数量                          |


## 并查集的 quick-find 实现

### 原理说明

* 用数组 `id[]` 记录，每个元素的“集合编号”或“代表元”。初始时 `id[i] = i`，各自为一集。
* **查找**：直接返回 `id[x]`，即 $x$ 属于哪个集合，**时间复杂度为 $\mathcal{O}(1)$**。
* **合并**：把两个集合的所有元素编号统一（即全体替换）。遍历一遍整个 `id[]`，
           把所有属于某集合的元素的集合编号都改掉，**时间复杂度为 $\mathcal{O}(n)$**。

### 例子

假如我们有如下初始状态（5个元素）：

| 下标 $i$ | 0 | 1 | 2 | 3 | 4 |
|--------|---|---|---|---|---|
| id\[i] | 0 | 1 | 2 | 3 | 4 |

* 合并(0,1)：
    * 把所有`id[]`值为`id[0]=0`的元素改为`id[1]=1`
* 合并(1,2)：
    * 把所有`id[]`值为`id[1]=1`的元素改为`id[2]=2`

如合并每一步后`id[]`的变化如下：

| 操作         | id\[]     |
|------------|-----------|
| 初始         | 0 1 2 3 4 |
| union(0,1) | 1 1 2 3 4 |
| union(1,2) | 2 2 2 3 4 |

### 代码实现

```java
// 初始化
int[] id = new int[n];
for (int i = 0; i < n; i++) id[i] = i;

// 查找集合编号
int find(int x) {
    return id[x];
}

// 合并
void union(int x, int y) {
    int idx = id[x], idy = id[y];
    if (idx == idy) return;
    for (int i = 0; i < id.length; i++) {
        if (id[i] == idx) id[i] = idy;
    }
}
```

### 复杂度分析

* 查找 $\mathcal{O}(1)$
* 合并 $\mathcal{O}(n)$（每次可能修改整个数组）

### 优缺点

* 优点：查找超快
* 缺点：合并十分慢，枚举所有点替换集合编号，**很难扩展到大数据场景**
* 实际工程/算法竞赛中，通常不用 quick-find，而用“树结构”实现的 quick-union + 路径压缩

### 例：「力扣」第 547 题：[朋友圈](https://leetcode.cn/problems/number-of-provinces)（ps. 现题目为省份数量）

#### 算法思路

1. **建模为图连通分量**

    * 每个城市为一个节点。
    * 依据 `isConnected` 构建图。
    * 目标：计算连通分量数量。

2. **并查集思想适用性**

    * 并查集非常适合用来维护“集合合并”的场景，能动态合并和查询城市归属的省份。
    * 省份个数即并查集的集合数，即不同根节点的数量。

3. **quick-find 并查集实现方案**

    * 使用一维数组 `id[]`，`id[i]` 表示**第 $i$ 个城市所属的省份编号**（代表元）。
    * 初始时各自唯一：`id[i]=i`
    * 若城市 $i$ 和 $j$ 直接连通，执行 quick-find 的合并操作（全体编号替换），把 $i$、 $j$ 所在的省份合并为一个。

#### 核心知识点与技巧

* **quick-find**：`id[x]` 存放集合编号，查找快（ $\mathcal{O}(1)$），合并慢（ $\mathcal{O}(n)$），每次合并需遍历所有元素。
* **连通分量数**：最终`id[]`中有多少不同数字，就是省份个数。
* **无向图**且输入对称，所以只需遍历 $i < j$ 的一半矩阵，不重复合并。

#### 代码实现

```java
public class NumberOfProvinces {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int[] id = new int[n];
        for (int i = 0; i < n; i++)
            id[i] = i;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1 && id[i] != id[j]) {
                    int from = id[i];
                    int to = id[j];
                    for (int k = 0; k < n; k++)
                        if (id[k] == from)
                            id[k] = to;
                }
            }
        }
        boolean[] vis = new boolean[n];
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[id[i]]) {
                count++;
                vis[id[i]] = true;
            }
        }
        return count;
    }
}
```

#### 复杂度分析

* 初始化： $\mathcal{O}(n)$
* 枚举城市对： $\mathcal{O}(n^2)$
* 每次合并最坏要遍历全体：合并操作最坏 $\mathcal{O}(n)$，总合并次数最大 $\mathcal{O}(n^2)$。
* **总时间复杂度： $\mathcal{O}(n^3)$**（理论最坏）
    * 不如路径压缩版高效，但学习 quick-find 推荐！
* 空间复杂度： $\mathcal{O}(n)$

## 并查集的 quick-union 实现

### 基本思想

* quick-union 是“树形结构”的并查集，核心思想是**只改变根结点，合并时只做一次父指针修改**，合并和查找都沿指针树走，不需要遍历全体。
* 用一维数组 `parent[]`，`parent[x]` 记录 $x$ 的父节点。
    * 如果 $x = parent[x]$，说明 $x$ 是自己的根（即集合代表元）。

### 操作详解

1. **查找（find 操作）**
    * 查找某个元素 $x$ 所属的集合代表元（根节点），不断向上查：
        * `while (x != parent[x]) x = parent[x];`
    * 路径：不断找父亲，直至树的根。

2. **合并（union 操作）**
    * 将两个不同集合合并，就是将一棵树的根挂到另一棵树的根下（合并“祖先”）。
        * 找到 $x$、 $y$ 的根（`find(x)`, `find(y)`），若两者不同，强制把一个根挂到另一个根即可（如`parent[rootX] = rootY`）。

3. **优化（可选：路径压缩、按秩合并）**
    * 基础 quick-union 不做路径压缩和按秩合并，树可能退化成链。
    * 但加了路径压缩/按秩优化后，性能极高，这也是现代模板。

### 代码实现（未优化版本）

```java
class QuickUnionUF {
    int[] parent;

    // 初始化
    public QuickUnionUF(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    // 查找根
    public int find(int x) {
        while (x != parent[x]) x = parent[x];
        return x;
    }

    // 合并
    public void union(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) return;
        parent[rootX] = rootY;
    }

    // 判断是否同一集合
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 复杂度分析

* **初始化**： $\mathcal{O}(n)$
* **查找**：最坏 $\mathcal{O}(n)$（树可能退化成链）
* **合并**：最坏 $\mathcal{O}(n)$
* 若采用路径压缩/按秩合并，性能可达近乎 $\mathcal{O}(1)$。

### 优缺点

#### 优点

* 合并操作只需父结点指针修改，无需全体遍历
* 数据量大时，比 quick-find 实用得多
* 基础框架容易加路径压缩/按秩优化

#### 缺点

* 若不优化，树可能退化成链，导致性能变差
* 真实竞赛/工程都推荐加路径压缩与按秩

### 完成「力扣」第 547 题：[朋友圈](https://leetcode.cn/problems/number-of-provinces)(即省份数量，用quick-union实现)

```java
public class NumberOfProvincesV2 {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    union(parent, i, j);
                }
            }
        }
        int provinces = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i) {
                provinces++;
            }
        }
        return provinces;
    }

    private void union(int[] parent, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
        }
    }

    private int find(int[] parent, int x) {
        while (x != parent[x]) x = parent[x];
        return x;
    }
}
```

#### quick-union 思路

quick-union 是一种并查集实现方式，它通过"向上查找父节点"来确定元素所属的集合。在这个问题中：

* 每个城市初始化为自己的集合
* 当两个城市连通时，将它们合并到同一集合
* 最后计算有多少个不同的集合，即为省份数

#### 整体步骤

1. 初始化并查集，每个城市指向自己作为根
2. 遍历邻接矩阵，将有连接的城市合并
3.  统计并查集中根节点的数量，即为省份数

#### 时间复杂度

* **时间复杂度**： $\mathcal{O}(n^3)$

    * 遍历邻接矩阵需要 $\mathcal{O}(n^2)$
    * 每次 find 操作最坏情况下需要 $\mathcal{O}(n)$

* **空间复杂度**： $\mathcal{O}(n)$，存储父节点数组

***注意这里的 quick-union 是基础版本，而非使用了路径压缩+按秩合并的优化版本***

---

[返回](../README.md)