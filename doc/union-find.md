<!-- TOC -->
* [并查集](#并查集)
  * [并查集简介](#并查集简介)
    * [并查集的基本思想](#并查集的基本思想)
    * [数据结构实现](#数据结构实现)
    * [基本代码](#基本代码)
    * [应用举例](#应用举例)
    * [并查集是树的集合](#并查集是树的集合)
    * [连通分量](#连通分量)
    * [理解「连通性」与「路径问题」](#理解连通性与路径问题)
    * [并查集的抽象数据类型](#并查集的抽象数据类型)
<!-- TOC -->

# 并查集

## 并查集简介

> 并查集（Union-Find Set，Disjoint Set Union，简称 DSU）是一种常用于解决“集合合并”与“查找连通性”问题的数据结构。
> 常见于处理“动态连通性”、“判断是否在同一集合”、“无向图判环”等场景，比如 Kruskal 最小生成树算法。

### 并查集的基本思想

主要支持两个操作：

1. **合并操作（Union）**：把两个集合合并为一个集合。
2. **查找操作（Find）**：判断某个元素属于哪个集合，通常找“代表元”或“根节点”。

### 数据结构实现

* 用数组 `parent[]` 记录每个元素的“父节点”。初始时，每个元素是自己的父节点，即独立集合。
* 查找时一路递归/迭代向上找，直到到达自己的根（即`parent[x] == x`）。
* 合并时，把一个元素的根节点挂到另一个根节点下。

**优化：路径压缩 + 按秩合并**

* 路径压缩：在`find`操作时，把沿途的点全部直接挂到根上，大大加速后续查找。
* 按秩/按大小合并：总是把个数少的/高度矮的集合并到多的/高的集合下，避免树变高。

这两个优化使得每次操作的均摊复杂度几乎是常数 $\mathcal{O}(1)$，实际上是 $\mathcal{O}(\alpha(n))$，
其中 $\alpha$是[反阿克曼函数](https://www.geeksforgeeks.org/inverse-ackermann-function/)。

### 基本代码

```java
// 初始化
int[] parent = new int[n];
for (int i = 0; i < n; i++) {
    parent[i] = i;
}

// 查找根节点 + 路径压缩
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

// 合并
void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        parent[rootX] = rootY;
    }
}
```

### 应用举例

* 判断两个元素是否属于同一个集合：比较`find(x)`和`find(y)`
* 求连通分量数量（如“朋友圈”问题）
* 动态连通性维护（如 Kruskal）

### 并查集是树的集合

* 每个集合对应“一棵树”。
* 树的每个节点代表一个元素，树的根节点代表这个集合的代表元（根）。
* 多个集合，实际上就是多棵互不相交的树的集合。

比如 $n$ 个初始元素，各自成集，每个都是单独的一棵树（单节点树）；随着合并过程，不断把树合并成更大的树，最终可能只剩下一棵大树（即所有元素全连通）。

**为什么用树？**

* 节点只需要记录“父节点是谁”，只需一个 `parent[]` 数组，空间和实现都很高效。
* 查找某元素属于哪个集合，只需往上查找其父亲直到根节点（树的根就是代表这个集合的标记）。
  * “查找”就是“向上找根结点”的过程。
* 合并两个集合，只需把一棵树的根挂到另一棵树的根下面。

### 连通分量

* 一个[无向图](https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/)中的“连通分量”指的是：极大地连通的子图。
* 在同一个连通分量里的任意两个顶点之间，都有路径能够互通。
* 不同连通分量之间，任意一对顶点都不连通。

1. **更通俗的理解**

    把无向图的所有节点想象成一群点，通过边连起来。如果一群点之间可以互相走到，那么它们属于同一个连通分量；走不到的，属于不同的连通分量。\
    比如下面这个无向图：

    ```
    A --- B --- C

    D --- E

    F
    ```

    这个图有：
    * $3$ 个连通分量：
      * ${A, B, C}$
      * ${D, E}$
      * ${F}$

2. **形式化定义**
 
   对于无向图 $G = (V, E)$：

   * 连通分量是极大的连通子图。极大是指：没有更多的顶点能加入当前子图而保持连通。

3. **和并查集的关系**

    * 用并查集维护连通分量时，每个连通分量就是并查集中一棵树。
    * 当我们对边 $(u, v)$ 执行合并操作时，就是把 $u$ 和 $v$ 两个连通分量合成一个。
    * 最终，树的数量（根结点的数量）就是连通分量数量。

    比如代码求无向图的连通分量个数：

    ```java
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (parent[i] == i) {
            count++; // 每个根就是一个连通分量
        }
    }
    ```

**总之连通分量就是一副图里“任意两点互通”的最大分组。用并查集，每个集合对应一个连通分量。**

### 理解「连通性」与「路径问题」

*这两个概念都与图论密不可分，是学习并查集以及常见算法题的基础。*

1. **连通性（Connectivity）**

    **定义：**

    * 连通性指的是图中任意两个点之间能否通过若干条边互相到达。
    * 在**无向图**里，只要有一条路径可以连接起 $u$ 和 $v$，则它们“连通”。
    * 如果图被分成了几块（连通分量），则不同分量之间任意两个点都无法互通。

    **例1：**

    * 下面的无向图中 $A, B, C, D$ 连通， $E, F$ 连通，但AB能不能走到E？不能——它们不连通。

      ```
      A---B---C
          |
          D     E---F
      ```

    **应用：**

    * 判断网络是否“整体连通”？
    * 两个人在朋友圈里是否能通过朋友关系互相认识？
    * 地图上岛屿块的数量

2. **路径问题（Path Problem）**

    **定义：**

    * 路径问题研究的是：从一个点 $u$ 到另一个点 $v$，是否存在一条边路径？如果有，路径最短是多少？一共有多少条？等等。
    * 路径可以有多种约束：最短路径、最大权路径、固定长度的路径等。

    **常见类型：**

    * 判断路径是否存在（可达问题）
    * 求最短/最长路径长度
    * 计算所有可能路径条数

    **例2：**

    * 在下图中，从 $A$ 到 $D$ 是否有路径？
      ```
      A---B---C
          |
          D
      ```
      可以走 $A \to B \to D$ 或 $A \to B \to C \to B \to D$（但第二条包含环，通常只关心最短路径）。

    **算法工具：**

    * 并查集解决“可达性/连通性”问题，即问“ $u$ 到 $v$ 有无路”。
    * BFS/DFS 或 Dijkstra 算法解决“路径长度/方案数/最短距离”等。

3. **两者区别和联系**

    * “连通性”问的是**能不能到**，简称“可达”（有路径即可，不关心具体路线）。
        * 只关心有无，典型用并查集、Flood Fill等方法。
    * “路径问题”关注**怎么到**、**多远**、有几种走法等。
        * 可能需要具体路线、最短距离、经过哪些节点等。

### 并查集的抽象数据类型

| 返回值       | 方法名                         | 方法描述                               |
|-----------|-----------------------------|------------------------------------|
| 构造函数无返回值  | `UnionFind(int N)`          | 初始化并查集                             |
| `void`    | `union(int x, int y)`       | 在 `x` 和 `y` 之间添加一条连接               |
| `int`     | `find(int x)`               | 返回 `x` 所在的连通分量的标识                  |
| `boolean` | `isConnected(int x, int y)` | 如果 `x` 和 `y` 存在于同一个连通分量中则返回 `true` |
| `int`     | `getCount()`                | 返回连通分量的数量                          |


---

[返回](../README.md)